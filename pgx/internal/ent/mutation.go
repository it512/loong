// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/it512/loong"
	"github.com/it512/loong/pgx/internal/ent/exec"
	"github.com/it512/loong/pgx/internal/ent/inst"
	"github.com/it512/loong/pgx/internal/ent/predicate"
	"github.com/it512/loong/pgx/internal/ent/usertask"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeExec     = "Exec"
	TypeInst     = "Inst"
	TypeUserTask = "UserTask"
)

// ExecMutation represents an operation that mutates the Exec nodes in the graph.
type ExecMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	exec_id        *string
	inst_id        *string
	parent_fork_id *string
	fork_id        *string
	fork_tag       *string
	out_tag        *string
	join_tag       *string
	gw_type        *int
	addgw_type     *int
	status         *int
	addstatus      *int
	version        *int
	addversion     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Exec, error)
	predicates     []predicate.Exec
}

var _ ent.Mutation = (*ExecMutation)(nil)

// execOption allows management of the mutation configuration using functional options.
type execOption func(*ExecMutation)

// newExecMutation creates new mutation for the Exec entity.
func newExecMutation(c config, op Op, opts ...execOption) *ExecMutation {
	m := &ExecMutation{
		config:        c,
		op:            op,
		typ:           TypeExec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExecID sets the ID field of the mutation.
func withExecID(id uuid.UUID) execOption {
	return func(m *ExecMutation) {
		var (
			err   error
			once  sync.Once
			value *Exec
		)
		m.oldValue = func(ctx context.Context) (*Exec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExec sets the old Exec of the mutation.
func withExec(node *Exec) execOption {
	return func(m *ExecMutation) {
		m.oldValue = func(context.Context) (*Exec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Exec entities.
func (m *ExecMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExecMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExecMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExecID sets the "exec_id" field.
func (m *ExecMutation) SetExecID(s string) {
	m.exec_id = &s
}

// ExecID returns the value of the "exec_id" field in the mutation.
func (m *ExecMutation) ExecID() (r string, exists bool) {
	v := m.exec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExecID returns the old "exec_id" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldExecID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecID: %w", err)
	}
	return oldValue.ExecID, nil
}

// ResetExecID resets all changes to the "exec_id" field.
func (m *ExecMutation) ResetExecID() {
	m.exec_id = nil
}

// SetInstID sets the "inst_id" field.
func (m *ExecMutation) SetInstID(s string) {
	m.inst_id = &s
}

// InstID returns the value of the "inst_id" field in the mutation.
func (m *ExecMutation) InstID() (r string, exists bool) {
	v := m.inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstID returns the old "inst_id" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldInstID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstID: %w", err)
	}
	return oldValue.InstID, nil
}

// ResetInstID resets all changes to the "inst_id" field.
func (m *ExecMutation) ResetInstID() {
	m.inst_id = nil
}

// SetParentForkID sets the "parent_fork_id" field.
func (m *ExecMutation) SetParentForkID(s string) {
	m.parent_fork_id = &s
}

// ParentForkID returns the value of the "parent_fork_id" field in the mutation.
func (m *ExecMutation) ParentForkID() (r string, exists bool) {
	v := m.parent_fork_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentForkID returns the old "parent_fork_id" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldParentForkID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentForkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentForkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentForkID: %w", err)
	}
	return oldValue.ParentForkID, nil
}

// ResetParentForkID resets all changes to the "parent_fork_id" field.
func (m *ExecMutation) ResetParentForkID() {
	m.parent_fork_id = nil
}

// SetForkID sets the "fork_id" field.
func (m *ExecMutation) SetForkID(s string) {
	m.fork_id = &s
}

// ForkID returns the value of the "fork_id" field in the mutation.
func (m *ExecMutation) ForkID() (r string, exists bool) {
	v := m.fork_id
	if v == nil {
		return
	}
	return *v, true
}

// OldForkID returns the old "fork_id" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldForkID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForkID: %w", err)
	}
	return oldValue.ForkID, nil
}

// ResetForkID resets all changes to the "fork_id" field.
func (m *ExecMutation) ResetForkID() {
	m.fork_id = nil
}

// SetForkTag sets the "fork_tag" field.
func (m *ExecMutation) SetForkTag(s string) {
	m.fork_tag = &s
}

// ForkTag returns the value of the "fork_tag" field in the mutation.
func (m *ExecMutation) ForkTag() (r string, exists bool) {
	v := m.fork_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldForkTag returns the old "fork_tag" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldForkTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForkTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForkTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForkTag: %w", err)
	}
	return oldValue.ForkTag, nil
}

// ResetForkTag resets all changes to the "fork_tag" field.
func (m *ExecMutation) ResetForkTag() {
	m.fork_tag = nil
}

// SetOutTag sets the "out_tag" field.
func (m *ExecMutation) SetOutTag(s string) {
	m.out_tag = &s
}

// OutTag returns the value of the "out_tag" field in the mutation.
func (m *ExecMutation) OutTag() (r string, exists bool) {
	v := m.out_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTag returns the old "out_tag" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldOutTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTag: %w", err)
	}
	return oldValue.OutTag, nil
}

// ResetOutTag resets all changes to the "out_tag" field.
func (m *ExecMutation) ResetOutTag() {
	m.out_tag = nil
}

// SetJoinTag sets the "join_tag" field.
func (m *ExecMutation) SetJoinTag(s string) {
	m.join_tag = &s
}

// JoinTag returns the value of the "join_tag" field in the mutation.
func (m *ExecMutation) JoinTag() (r string, exists bool) {
	v := m.join_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinTag returns the old "join_tag" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldJoinTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinTag: %w", err)
	}
	return oldValue.JoinTag, nil
}

// ClearJoinTag clears the value of the "join_tag" field.
func (m *ExecMutation) ClearJoinTag() {
	m.join_tag = nil
	m.clearedFields[exec.FieldJoinTag] = struct{}{}
}

// JoinTagCleared returns if the "join_tag" field was cleared in this mutation.
func (m *ExecMutation) JoinTagCleared() bool {
	_, ok := m.clearedFields[exec.FieldJoinTag]
	return ok
}

// ResetJoinTag resets all changes to the "join_tag" field.
func (m *ExecMutation) ResetJoinTag() {
	m.join_tag = nil
	delete(m.clearedFields, exec.FieldJoinTag)
}

// SetGwType sets the "gw_type" field.
func (m *ExecMutation) SetGwType(i int) {
	m.gw_type = &i
	m.addgw_type = nil
}

// GwType returns the value of the "gw_type" field in the mutation.
func (m *ExecMutation) GwType() (r int, exists bool) {
	v := m.gw_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGwType returns the old "gw_type" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldGwType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGwType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGwType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGwType: %w", err)
	}
	return oldValue.GwType, nil
}

// AddGwType adds i to the "gw_type" field.
func (m *ExecMutation) AddGwType(i int) {
	if m.addgw_type != nil {
		*m.addgw_type += i
	} else {
		m.addgw_type = &i
	}
}

// AddedGwType returns the value that was added to the "gw_type" field in this mutation.
func (m *ExecMutation) AddedGwType() (r int, exists bool) {
	v := m.addgw_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetGwType resets all changes to the "gw_type" field.
func (m *ExecMutation) ResetGwType() {
	m.gw_type = nil
	m.addgw_type = nil
}

// SetStatus sets the "status" field.
func (m *ExecMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExecMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ExecMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExecMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ExecMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetVersion sets the "version" field.
func (m *ExecMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ExecMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Exec entity.
// If the Exec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExecMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ExecMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ExecMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ExecMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Where appends a list predicates to the ExecMutation builder.
func (m *ExecMutation) Where(ps ...predicate.Exec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exec).
func (m *ExecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExecMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.exec_id != nil {
		fields = append(fields, exec.FieldExecID)
	}
	if m.inst_id != nil {
		fields = append(fields, exec.FieldInstID)
	}
	if m.parent_fork_id != nil {
		fields = append(fields, exec.FieldParentForkID)
	}
	if m.fork_id != nil {
		fields = append(fields, exec.FieldForkID)
	}
	if m.fork_tag != nil {
		fields = append(fields, exec.FieldForkTag)
	}
	if m.out_tag != nil {
		fields = append(fields, exec.FieldOutTag)
	}
	if m.join_tag != nil {
		fields = append(fields, exec.FieldJoinTag)
	}
	if m.gw_type != nil {
		fields = append(fields, exec.FieldGwType)
	}
	if m.status != nil {
		fields = append(fields, exec.FieldStatus)
	}
	if m.version != nil {
		fields = append(fields, exec.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exec.FieldExecID:
		return m.ExecID()
	case exec.FieldInstID:
		return m.InstID()
	case exec.FieldParentForkID:
		return m.ParentForkID()
	case exec.FieldForkID:
		return m.ForkID()
	case exec.FieldForkTag:
		return m.ForkTag()
	case exec.FieldOutTag:
		return m.OutTag()
	case exec.FieldJoinTag:
		return m.JoinTag()
	case exec.FieldGwType:
		return m.GwType()
	case exec.FieldStatus:
		return m.Status()
	case exec.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exec.FieldExecID:
		return m.OldExecID(ctx)
	case exec.FieldInstID:
		return m.OldInstID(ctx)
	case exec.FieldParentForkID:
		return m.OldParentForkID(ctx)
	case exec.FieldForkID:
		return m.OldForkID(ctx)
	case exec.FieldForkTag:
		return m.OldForkTag(ctx)
	case exec.FieldOutTag:
		return m.OldOutTag(ctx)
	case exec.FieldJoinTag:
		return m.OldJoinTag(ctx)
	case exec.FieldGwType:
		return m.OldGwType(ctx)
	case exec.FieldStatus:
		return m.OldStatus(ctx)
	case exec.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Exec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exec.FieldExecID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecID(v)
		return nil
	case exec.FieldInstID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstID(v)
		return nil
	case exec.FieldParentForkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentForkID(v)
		return nil
	case exec.FieldForkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForkID(v)
		return nil
	case exec.FieldForkTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForkTag(v)
		return nil
	case exec.FieldOutTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTag(v)
		return nil
	case exec.FieldJoinTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinTag(v)
		return nil
	case exec.FieldGwType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGwType(v)
		return nil
	case exec.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exec.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Exec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExecMutation) AddedFields() []string {
	var fields []string
	if m.addgw_type != nil {
		fields = append(fields, exec.FieldGwType)
	}
	if m.addstatus != nil {
		fields = append(fields, exec.FieldStatus)
	}
	if m.addversion != nil {
		fields = append(fields, exec.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exec.FieldGwType:
		return m.AddedGwType()
	case exec.FieldStatus:
		return m.AddedStatus()
	case exec.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exec.FieldGwType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGwType(v)
		return nil
	case exec.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case exec.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Exec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExecMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exec.FieldJoinTag) {
		fields = append(fields, exec.FieldJoinTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExecMutation) ClearField(name string) error {
	switch name {
	case exec.FieldJoinTag:
		m.ClearJoinTag()
		return nil
	}
	return fmt.Errorf("unknown Exec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExecMutation) ResetField(name string) error {
	switch name {
	case exec.FieldExecID:
		m.ResetExecID()
		return nil
	case exec.FieldInstID:
		m.ResetInstID()
		return nil
	case exec.FieldParentForkID:
		m.ResetParentForkID()
		return nil
	case exec.FieldForkID:
		m.ResetForkID()
		return nil
	case exec.FieldForkTag:
		m.ResetForkTag()
		return nil
	case exec.FieldOutTag:
		m.ResetOutTag()
		return nil
	case exec.FieldJoinTag:
		m.ResetJoinTag()
		return nil
	case exec.FieldGwType:
		m.ResetGwType()
		return nil
	case exec.FieldStatus:
		m.ResetStatus()
		return nil
	case exec.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Exec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExecMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExecMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExecMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExecMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExecMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Exec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExecMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Exec edge %s", name)
}

// InstMutation represents an operation that mutates the Inst nodes in the graph.
type InstMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	inst_id       *string
	proc_id       *string
	busi_key      *string
	busi_type     *string
	starter       *string
	start_time    *time.Time
	end_time      *time.Time
	init          *loong.Var
	status        *int
	addstatus     *int
	version       *int
	addversion    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Inst, error)
	predicates    []predicate.Inst
}

var _ ent.Mutation = (*InstMutation)(nil)

// instOption allows management of the mutation configuration using functional options.
type instOption func(*InstMutation)

// newInstMutation creates new mutation for the Inst entity.
func newInstMutation(c config, op Op, opts ...instOption) *InstMutation {
	m := &InstMutation{
		config:        c,
		op:            op,
		typ:           TypeInst,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstID sets the ID field of the mutation.
func withInstID(id uuid.UUID) instOption {
	return func(m *InstMutation) {
		var (
			err   error
			once  sync.Once
			value *Inst
		)
		m.oldValue = func(ctx context.Context) (*Inst, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inst.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInst sets the old Inst of the mutation.
func withInst(node *Inst) instOption {
	return func(m *InstMutation) {
		m.oldValue = func(context.Context) (*Inst, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inst entities.
func (m *InstMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inst.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstID sets the "inst_id" field.
func (m *InstMutation) SetInstID(s string) {
	m.inst_id = &s
}

// InstID returns the value of the "inst_id" field in the mutation.
func (m *InstMutation) InstID() (r string, exists bool) {
	v := m.inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstID returns the old "inst_id" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldInstID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstID: %w", err)
	}
	return oldValue.InstID, nil
}

// ResetInstID resets all changes to the "inst_id" field.
func (m *InstMutation) ResetInstID() {
	m.inst_id = nil
}

// SetProcID sets the "proc_id" field.
func (m *InstMutation) SetProcID(s string) {
	m.proc_id = &s
}

// ProcID returns the value of the "proc_id" field in the mutation.
func (m *InstMutation) ProcID() (r string, exists bool) {
	v := m.proc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcID returns the old "proc_id" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldProcID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcID: %w", err)
	}
	return oldValue.ProcID, nil
}

// ResetProcID resets all changes to the "proc_id" field.
func (m *InstMutation) ResetProcID() {
	m.proc_id = nil
}

// SetBusiKey sets the "busi_key" field.
func (m *InstMutation) SetBusiKey(s string) {
	m.busi_key = &s
}

// BusiKey returns the value of the "busi_key" field in the mutation.
func (m *InstMutation) BusiKey() (r string, exists bool) {
	v := m.busi_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusiKey returns the old "busi_key" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldBusiKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusiKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusiKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusiKey: %w", err)
	}
	return oldValue.BusiKey, nil
}

// ResetBusiKey resets all changes to the "busi_key" field.
func (m *InstMutation) ResetBusiKey() {
	m.busi_key = nil
}

// SetBusiType sets the "busi_type" field.
func (m *InstMutation) SetBusiType(s string) {
	m.busi_type = &s
}

// BusiType returns the value of the "busi_type" field in the mutation.
func (m *InstMutation) BusiType() (r string, exists bool) {
	v := m.busi_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusiType returns the old "busi_type" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldBusiType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusiType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusiType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusiType: %w", err)
	}
	return oldValue.BusiType, nil
}

// ResetBusiType resets all changes to the "busi_type" field.
func (m *InstMutation) ResetBusiType() {
	m.busi_type = nil
}

// SetStarter sets the "starter" field.
func (m *InstMutation) SetStarter(s string) {
	m.starter = &s
}

// Starter returns the value of the "starter" field in the mutation.
func (m *InstMutation) Starter() (r string, exists bool) {
	v := m.starter
	if v == nil {
		return
	}
	return *v, true
}

// OldStarter returns the old "starter" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldStarter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarter: %w", err)
	}
	return oldValue.Starter, nil
}

// ResetStarter resets all changes to the "starter" field.
func (m *InstMutation) ResetStarter() {
	m.starter = nil
}

// SetStartTime sets the "start_time" field.
func (m *InstMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *InstMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *InstMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *InstMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *InstMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *InstMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[inst.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *InstMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[inst.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *InstMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, inst.FieldEndTime)
}

// SetInit sets the "init" field.
func (m *InstMutation) SetInit(l loong.Var) {
	m.init = &l
}

// Init returns the value of the "init" field in the mutation.
func (m *InstMutation) Init() (r loong.Var, exists bool) {
	v := m.init
	if v == nil {
		return
	}
	return *v, true
}

// OldInit returns the old "init" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldInit(ctx context.Context) (v loong.Var, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInit: %w", err)
	}
	return oldValue.Init, nil
}

// ResetInit resets all changes to the "init" field.
func (m *InstMutation) ResetInit() {
	m.init = nil
}

// SetStatus sets the "status" field.
func (m *InstMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *InstMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *InstMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *InstMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *InstMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetVersion sets the "version" field.
func (m *InstMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *InstMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Inst entity.
// If the Inst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *InstMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *InstMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *InstMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Where appends a list predicates to the InstMutation builder.
func (m *InstMutation) Where(ps ...predicate.Inst) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inst, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inst).
func (m *InstMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.inst_id != nil {
		fields = append(fields, inst.FieldInstID)
	}
	if m.proc_id != nil {
		fields = append(fields, inst.FieldProcID)
	}
	if m.busi_key != nil {
		fields = append(fields, inst.FieldBusiKey)
	}
	if m.busi_type != nil {
		fields = append(fields, inst.FieldBusiType)
	}
	if m.starter != nil {
		fields = append(fields, inst.FieldStarter)
	}
	if m.start_time != nil {
		fields = append(fields, inst.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, inst.FieldEndTime)
	}
	if m.init != nil {
		fields = append(fields, inst.FieldInit)
	}
	if m.status != nil {
		fields = append(fields, inst.FieldStatus)
	}
	if m.version != nil {
		fields = append(fields, inst.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inst.FieldInstID:
		return m.InstID()
	case inst.FieldProcID:
		return m.ProcID()
	case inst.FieldBusiKey:
		return m.BusiKey()
	case inst.FieldBusiType:
		return m.BusiType()
	case inst.FieldStarter:
		return m.Starter()
	case inst.FieldStartTime:
		return m.StartTime()
	case inst.FieldEndTime:
		return m.EndTime()
	case inst.FieldInit:
		return m.Init()
	case inst.FieldStatus:
		return m.Status()
	case inst.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inst.FieldInstID:
		return m.OldInstID(ctx)
	case inst.FieldProcID:
		return m.OldProcID(ctx)
	case inst.FieldBusiKey:
		return m.OldBusiKey(ctx)
	case inst.FieldBusiType:
		return m.OldBusiType(ctx)
	case inst.FieldStarter:
		return m.OldStarter(ctx)
	case inst.FieldStartTime:
		return m.OldStartTime(ctx)
	case inst.FieldEndTime:
		return m.OldEndTime(ctx)
	case inst.FieldInit:
		return m.OldInit(ctx)
	case inst.FieldStatus:
		return m.OldStatus(ctx)
	case inst.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Inst field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inst.FieldInstID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstID(v)
		return nil
	case inst.FieldProcID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcID(v)
		return nil
	case inst.FieldBusiKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusiKey(v)
		return nil
	case inst.FieldBusiType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusiType(v)
		return nil
	case inst.FieldStarter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarter(v)
		return nil
	case inst.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case inst.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case inst.FieldInit:
		v, ok := value.(loong.Var)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInit(v)
		return nil
	case inst.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inst.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Inst field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, inst.FieldStatus)
	}
	if m.addversion != nil {
		fields = append(fields, inst.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inst.FieldStatus:
		return m.AddedStatus()
	case inst.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inst.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case inst.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Inst numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inst.FieldEndTime) {
		fields = append(fields, inst.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstMutation) ClearField(name string) error {
	switch name {
	case inst.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown Inst nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstMutation) ResetField(name string) error {
	switch name {
	case inst.FieldInstID:
		m.ResetInstID()
		return nil
	case inst.FieldProcID:
		m.ResetProcID()
		return nil
	case inst.FieldBusiKey:
		m.ResetBusiKey()
		return nil
	case inst.FieldBusiType:
		m.ResetBusiType()
		return nil
	case inst.FieldStarter:
		m.ResetStarter()
		return nil
	case inst.FieldStartTime:
		m.ResetStartTime()
		return nil
	case inst.FieldEndTime:
		m.ResetEndTime()
		return nil
	case inst.FieldInit:
		m.ResetInit()
		return nil
	case inst.FieldStatus:
		m.ResetStatus()
		return nil
	case inst.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown Inst field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inst unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inst edge %s", name)
}

// UserTaskMutation represents an operation that mutates the UserTask nodes in the graph.
type UserTaskMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	task_id          *string
	inst_id          *string
	exec_id          *string
	busi_key         *string
	busi_type        *string
	form_key         *string
	act_id           *string
	act_name         *string
	owner            *string
	assignee         *string
	candidate_users  *string
	candidate_groups *string
	operator         *string
	input            *loong.Var
	batch_no         *string
	result           *int
	addresult        *int
	start_time       *time.Time
	end_time         *time.Time
	status           *int
	addstatus        *int
	version          *int
	addversion       *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*UserTask, error)
	predicates       []predicate.UserTask
}

var _ ent.Mutation = (*UserTaskMutation)(nil)

// usertaskOption allows management of the mutation configuration using functional options.
type usertaskOption func(*UserTaskMutation)

// newUserTaskMutation creates new mutation for the UserTask entity.
func newUserTaskMutation(c config, op Op, opts ...usertaskOption) *UserTaskMutation {
	m := &UserTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTaskID sets the ID field of the mutation.
func withUserTaskID(id uuid.UUID) usertaskOption {
	return func(m *UserTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *UserTask
		)
		m.oldValue = func(ctx context.Context) (*UserTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserTask sets the old UserTask of the mutation.
func withUserTask(node *UserTask) usertaskOption {
	return func(m *UserTaskMutation) {
		m.oldValue = func(context.Context) (*UserTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserTask entities.
func (m *UserTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *UserTaskMutation) SetTaskID(s string) {
	m.task_id = &s
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *UserTaskMutation) TaskID() (r string, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldTaskID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *UserTaskMutation) ResetTaskID() {
	m.task_id = nil
}

// SetInstID sets the "inst_id" field.
func (m *UserTaskMutation) SetInstID(s string) {
	m.inst_id = &s
}

// InstID returns the value of the "inst_id" field in the mutation.
func (m *UserTaskMutation) InstID() (r string, exists bool) {
	v := m.inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstID returns the old "inst_id" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldInstID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstID: %w", err)
	}
	return oldValue.InstID, nil
}

// ResetInstID resets all changes to the "inst_id" field.
func (m *UserTaskMutation) ResetInstID() {
	m.inst_id = nil
}

// SetExecID sets the "exec_id" field.
func (m *UserTaskMutation) SetExecID(s string) {
	m.exec_id = &s
}

// ExecID returns the value of the "exec_id" field in the mutation.
func (m *UserTaskMutation) ExecID() (r string, exists bool) {
	v := m.exec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExecID returns the old "exec_id" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldExecID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecID: %w", err)
	}
	return oldValue.ExecID, nil
}

// ClearExecID clears the value of the "exec_id" field.
func (m *UserTaskMutation) ClearExecID() {
	m.exec_id = nil
	m.clearedFields[usertask.FieldExecID] = struct{}{}
}

// ExecIDCleared returns if the "exec_id" field was cleared in this mutation.
func (m *UserTaskMutation) ExecIDCleared() bool {
	_, ok := m.clearedFields[usertask.FieldExecID]
	return ok
}

// ResetExecID resets all changes to the "exec_id" field.
func (m *UserTaskMutation) ResetExecID() {
	m.exec_id = nil
	delete(m.clearedFields, usertask.FieldExecID)
}

// SetBusiKey sets the "busi_key" field.
func (m *UserTaskMutation) SetBusiKey(s string) {
	m.busi_key = &s
}

// BusiKey returns the value of the "busi_key" field in the mutation.
func (m *UserTaskMutation) BusiKey() (r string, exists bool) {
	v := m.busi_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusiKey returns the old "busi_key" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldBusiKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusiKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusiKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusiKey: %w", err)
	}
	return oldValue.BusiKey, nil
}

// ResetBusiKey resets all changes to the "busi_key" field.
func (m *UserTaskMutation) ResetBusiKey() {
	m.busi_key = nil
}

// SetBusiType sets the "busi_type" field.
func (m *UserTaskMutation) SetBusiType(s string) {
	m.busi_type = &s
}

// BusiType returns the value of the "busi_type" field in the mutation.
func (m *UserTaskMutation) BusiType() (r string, exists bool) {
	v := m.busi_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusiType returns the old "busi_type" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldBusiType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusiType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusiType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusiType: %w", err)
	}
	return oldValue.BusiType, nil
}

// ResetBusiType resets all changes to the "busi_type" field.
func (m *UserTaskMutation) ResetBusiType() {
	m.busi_type = nil
}

// SetFormKey sets the "form_key" field.
func (m *UserTaskMutation) SetFormKey(s string) {
	m.form_key = &s
}

// FormKey returns the value of the "form_key" field in the mutation.
func (m *UserTaskMutation) FormKey() (r string, exists bool) {
	v := m.form_key
	if v == nil {
		return
	}
	return *v, true
}

// OldFormKey returns the old "form_key" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldFormKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormKey: %w", err)
	}
	return oldValue.FormKey, nil
}

// ClearFormKey clears the value of the "form_key" field.
func (m *UserTaskMutation) ClearFormKey() {
	m.form_key = nil
	m.clearedFields[usertask.FieldFormKey] = struct{}{}
}

// FormKeyCleared returns if the "form_key" field was cleared in this mutation.
func (m *UserTaskMutation) FormKeyCleared() bool {
	_, ok := m.clearedFields[usertask.FieldFormKey]
	return ok
}

// ResetFormKey resets all changes to the "form_key" field.
func (m *UserTaskMutation) ResetFormKey() {
	m.form_key = nil
	delete(m.clearedFields, usertask.FieldFormKey)
}

// SetActID sets the "act_id" field.
func (m *UserTaskMutation) SetActID(s string) {
	m.act_id = &s
}

// ActID returns the value of the "act_id" field in the mutation.
func (m *UserTaskMutation) ActID() (r string, exists bool) {
	v := m.act_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActID returns the old "act_id" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldActID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActID: %w", err)
	}
	return oldValue.ActID, nil
}

// ResetActID resets all changes to the "act_id" field.
func (m *UserTaskMutation) ResetActID() {
	m.act_id = nil
}

// SetActName sets the "act_name" field.
func (m *UserTaskMutation) SetActName(s string) {
	m.act_name = &s
}

// ActName returns the value of the "act_name" field in the mutation.
func (m *UserTaskMutation) ActName() (r string, exists bool) {
	v := m.act_name
	if v == nil {
		return
	}
	return *v, true
}

// OldActName returns the old "act_name" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldActName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActName: %w", err)
	}
	return oldValue.ActName, nil
}

// ClearActName clears the value of the "act_name" field.
func (m *UserTaskMutation) ClearActName() {
	m.act_name = nil
	m.clearedFields[usertask.FieldActName] = struct{}{}
}

// ActNameCleared returns if the "act_name" field was cleared in this mutation.
func (m *UserTaskMutation) ActNameCleared() bool {
	_, ok := m.clearedFields[usertask.FieldActName]
	return ok
}

// ResetActName resets all changes to the "act_name" field.
func (m *UserTaskMutation) ResetActName() {
	m.act_name = nil
	delete(m.clearedFields, usertask.FieldActName)
}

// SetOwner sets the "owner" field.
func (m *UserTaskMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *UserTaskMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ClearOwner clears the value of the "owner" field.
func (m *UserTaskMutation) ClearOwner() {
	m.owner = nil
	m.clearedFields[usertask.FieldOwner] = struct{}{}
}

// OwnerCleared returns if the "owner" field was cleared in this mutation.
func (m *UserTaskMutation) OwnerCleared() bool {
	_, ok := m.clearedFields[usertask.FieldOwner]
	return ok
}

// ResetOwner resets all changes to the "owner" field.
func (m *UserTaskMutation) ResetOwner() {
	m.owner = nil
	delete(m.clearedFields, usertask.FieldOwner)
}

// SetAssignee sets the "assignee" field.
func (m *UserTaskMutation) SetAssignee(s string) {
	m.assignee = &s
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *UserTaskMutation) Assignee() (r string, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldAssignee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// ClearAssignee clears the value of the "assignee" field.
func (m *UserTaskMutation) ClearAssignee() {
	m.assignee = nil
	m.clearedFields[usertask.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *UserTaskMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[usertask.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *UserTaskMutation) ResetAssignee() {
	m.assignee = nil
	delete(m.clearedFields, usertask.FieldAssignee)
}

// SetCandidateUsers sets the "candidate_users" field.
func (m *UserTaskMutation) SetCandidateUsers(s string) {
	m.candidate_users = &s
}

// CandidateUsers returns the value of the "candidate_users" field in the mutation.
func (m *UserTaskMutation) CandidateUsers() (r string, exists bool) {
	v := m.candidate_users
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateUsers returns the old "candidate_users" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldCandidateUsers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateUsers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateUsers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateUsers: %w", err)
	}
	return oldValue.CandidateUsers, nil
}

// ClearCandidateUsers clears the value of the "candidate_users" field.
func (m *UserTaskMutation) ClearCandidateUsers() {
	m.candidate_users = nil
	m.clearedFields[usertask.FieldCandidateUsers] = struct{}{}
}

// CandidateUsersCleared returns if the "candidate_users" field was cleared in this mutation.
func (m *UserTaskMutation) CandidateUsersCleared() bool {
	_, ok := m.clearedFields[usertask.FieldCandidateUsers]
	return ok
}

// ResetCandidateUsers resets all changes to the "candidate_users" field.
func (m *UserTaskMutation) ResetCandidateUsers() {
	m.candidate_users = nil
	delete(m.clearedFields, usertask.FieldCandidateUsers)
}

// SetCandidateGroups sets the "candidate_groups" field.
func (m *UserTaskMutation) SetCandidateGroups(s string) {
	m.candidate_groups = &s
}

// CandidateGroups returns the value of the "candidate_groups" field in the mutation.
func (m *UserTaskMutation) CandidateGroups() (r string, exists bool) {
	v := m.candidate_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateGroups returns the old "candidate_groups" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldCandidateGroups(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateGroups: %w", err)
	}
	return oldValue.CandidateGroups, nil
}

// ClearCandidateGroups clears the value of the "candidate_groups" field.
func (m *UserTaskMutation) ClearCandidateGroups() {
	m.candidate_groups = nil
	m.clearedFields[usertask.FieldCandidateGroups] = struct{}{}
}

// CandidateGroupsCleared returns if the "candidate_groups" field was cleared in this mutation.
func (m *UserTaskMutation) CandidateGroupsCleared() bool {
	_, ok := m.clearedFields[usertask.FieldCandidateGroups]
	return ok
}

// ResetCandidateGroups resets all changes to the "candidate_groups" field.
func (m *UserTaskMutation) ResetCandidateGroups() {
	m.candidate_groups = nil
	delete(m.clearedFields, usertask.FieldCandidateGroups)
}

// SetOperator sets the "operator" field.
func (m *UserTaskMutation) SetOperator(s string) {
	m.operator = &s
}

// Operator returns the value of the "operator" field in the mutation.
func (m *UserTaskMutation) Operator() (r string, exists bool) {
	v := m.operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOperator returns the old "operator" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldOperator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperator: %w", err)
	}
	return oldValue.Operator, nil
}

// ClearOperator clears the value of the "operator" field.
func (m *UserTaskMutation) ClearOperator() {
	m.operator = nil
	m.clearedFields[usertask.FieldOperator] = struct{}{}
}

// OperatorCleared returns if the "operator" field was cleared in this mutation.
func (m *UserTaskMutation) OperatorCleared() bool {
	_, ok := m.clearedFields[usertask.FieldOperator]
	return ok
}

// ResetOperator resets all changes to the "operator" field.
func (m *UserTaskMutation) ResetOperator() {
	m.operator = nil
	delete(m.clearedFields, usertask.FieldOperator)
}

// SetInput sets the "input" field.
func (m *UserTaskMutation) SetInput(l loong.Var) {
	m.input = &l
}

// Input returns the value of the "input" field in the mutation.
func (m *UserTaskMutation) Input() (r loong.Var, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldInput(ctx context.Context) (v loong.Var, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *UserTaskMutation) ResetInput() {
	m.input = nil
}

// SetBatchNo sets the "batch_no" field.
func (m *UserTaskMutation) SetBatchNo(s string) {
	m.batch_no = &s
}

// BatchNo returns the value of the "batch_no" field in the mutation.
func (m *UserTaskMutation) BatchNo() (r string, exists bool) {
	v := m.batch_no
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchNo returns the old "batch_no" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldBatchNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchNo: %w", err)
	}
	return oldValue.BatchNo, nil
}

// ResetBatchNo resets all changes to the "batch_no" field.
func (m *UserTaskMutation) ResetBatchNo() {
	m.batch_no = nil
}

// SetResult sets the "result" field.
func (m *UserTaskMutation) SetResult(i int) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *UserTaskMutation) Result() (r int, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldResult(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *UserTaskMutation) AddResult(i int) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *UserTaskMutation) AddedResult() (r int, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ClearResult clears the value of the "result" field.
func (m *UserTaskMutation) ClearResult() {
	m.result = nil
	m.addresult = nil
	m.clearedFields[usertask.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *UserTaskMutation) ResultCleared() bool {
	_, ok := m.clearedFields[usertask.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *UserTaskMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
	delete(m.clearedFields, usertask.FieldResult)
}

// SetStartTime sets the "start_time" field.
func (m *UserTaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *UserTaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *UserTaskMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *UserTaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *UserTaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *UserTaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[usertask.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *UserTaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[usertask.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *UserTaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, usertask.FieldEndTime)
}

// SetStatus sets the "status" field.
func (m *UserTaskMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserTaskMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserTaskMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserTaskMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserTaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetVersion sets the "version" field.
func (m *UserTaskMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *UserTaskMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the UserTask entity.
// If the UserTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTaskMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *UserTaskMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *UserTaskMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *UserTaskMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// Where appends a list predicates to the UserTaskMutation builder.
func (m *UserTaskMutation) Where(ps ...predicate.UserTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTask).
func (m *UserTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTaskMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.task_id != nil {
		fields = append(fields, usertask.FieldTaskID)
	}
	if m.inst_id != nil {
		fields = append(fields, usertask.FieldInstID)
	}
	if m.exec_id != nil {
		fields = append(fields, usertask.FieldExecID)
	}
	if m.busi_key != nil {
		fields = append(fields, usertask.FieldBusiKey)
	}
	if m.busi_type != nil {
		fields = append(fields, usertask.FieldBusiType)
	}
	if m.form_key != nil {
		fields = append(fields, usertask.FieldFormKey)
	}
	if m.act_id != nil {
		fields = append(fields, usertask.FieldActID)
	}
	if m.act_name != nil {
		fields = append(fields, usertask.FieldActName)
	}
	if m.owner != nil {
		fields = append(fields, usertask.FieldOwner)
	}
	if m.assignee != nil {
		fields = append(fields, usertask.FieldAssignee)
	}
	if m.candidate_users != nil {
		fields = append(fields, usertask.FieldCandidateUsers)
	}
	if m.candidate_groups != nil {
		fields = append(fields, usertask.FieldCandidateGroups)
	}
	if m.operator != nil {
		fields = append(fields, usertask.FieldOperator)
	}
	if m.input != nil {
		fields = append(fields, usertask.FieldInput)
	}
	if m.batch_no != nil {
		fields = append(fields, usertask.FieldBatchNo)
	}
	if m.result != nil {
		fields = append(fields, usertask.FieldResult)
	}
	if m.start_time != nil {
		fields = append(fields, usertask.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, usertask.FieldEndTime)
	}
	if m.status != nil {
		fields = append(fields, usertask.FieldStatus)
	}
	if m.version != nil {
		fields = append(fields, usertask.FieldVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertask.FieldTaskID:
		return m.TaskID()
	case usertask.FieldInstID:
		return m.InstID()
	case usertask.FieldExecID:
		return m.ExecID()
	case usertask.FieldBusiKey:
		return m.BusiKey()
	case usertask.FieldBusiType:
		return m.BusiType()
	case usertask.FieldFormKey:
		return m.FormKey()
	case usertask.FieldActID:
		return m.ActID()
	case usertask.FieldActName:
		return m.ActName()
	case usertask.FieldOwner:
		return m.Owner()
	case usertask.FieldAssignee:
		return m.Assignee()
	case usertask.FieldCandidateUsers:
		return m.CandidateUsers()
	case usertask.FieldCandidateGroups:
		return m.CandidateGroups()
	case usertask.FieldOperator:
		return m.Operator()
	case usertask.FieldInput:
		return m.Input()
	case usertask.FieldBatchNo:
		return m.BatchNo()
	case usertask.FieldResult:
		return m.Result()
	case usertask.FieldStartTime:
		return m.StartTime()
	case usertask.FieldEndTime:
		return m.EndTime()
	case usertask.FieldStatus:
		return m.Status()
	case usertask.FieldVersion:
		return m.Version()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertask.FieldTaskID:
		return m.OldTaskID(ctx)
	case usertask.FieldInstID:
		return m.OldInstID(ctx)
	case usertask.FieldExecID:
		return m.OldExecID(ctx)
	case usertask.FieldBusiKey:
		return m.OldBusiKey(ctx)
	case usertask.FieldBusiType:
		return m.OldBusiType(ctx)
	case usertask.FieldFormKey:
		return m.OldFormKey(ctx)
	case usertask.FieldActID:
		return m.OldActID(ctx)
	case usertask.FieldActName:
		return m.OldActName(ctx)
	case usertask.FieldOwner:
		return m.OldOwner(ctx)
	case usertask.FieldAssignee:
		return m.OldAssignee(ctx)
	case usertask.FieldCandidateUsers:
		return m.OldCandidateUsers(ctx)
	case usertask.FieldCandidateGroups:
		return m.OldCandidateGroups(ctx)
	case usertask.FieldOperator:
		return m.OldOperator(ctx)
	case usertask.FieldInput:
		return m.OldInput(ctx)
	case usertask.FieldBatchNo:
		return m.OldBatchNo(ctx)
	case usertask.FieldResult:
		return m.OldResult(ctx)
	case usertask.FieldStartTime:
		return m.OldStartTime(ctx)
	case usertask.FieldEndTime:
		return m.OldEndTime(ctx)
	case usertask.FieldStatus:
		return m.OldStatus(ctx)
	case usertask.FieldVersion:
		return m.OldVersion(ctx)
	}
	return nil, fmt.Errorf("unknown UserTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertask.FieldTaskID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case usertask.FieldInstID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstID(v)
		return nil
	case usertask.FieldExecID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecID(v)
		return nil
	case usertask.FieldBusiKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusiKey(v)
		return nil
	case usertask.FieldBusiType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusiType(v)
		return nil
	case usertask.FieldFormKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormKey(v)
		return nil
	case usertask.FieldActID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActID(v)
		return nil
	case usertask.FieldActName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActName(v)
		return nil
	case usertask.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case usertask.FieldAssignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case usertask.FieldCandidateUsers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateUsers(v)
		return nil
	case usertask.FieldCandidateGroups:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateGroups(v)
		return nil
	case usertask.FieldOperator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperator(v)
		return nil
	case usertask.FieldInput:
		v, ok := value.(loong.Var)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case usertask.FieldBatchNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchNo(v)
		return nil
	case usertask.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case usertask.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case usertask.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case usertask.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usertask.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTaskMutation) AddedFields() []string {
	var fields []string
	if m.addresult != nil {
		fields = append(fields, usertask.FieldResult)
	}
	if m.addstatus != nil {
		fields = append(fields, usertask.FieldStatus)
	}
	if m.addversion != nil {
		fields = append(fields, usertask.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usertask.FieldResult:
		return m.AddedResult()
	case usertask.FieldStatus:
		return m.AddedStatus()
	case usertask.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usertask.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	case usertask.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case usertask.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertask.FieldExecID) {
		fields = append(fields, usertask.FieldExecID)
	}
	if m.FieldCleared(usertask.FieldFormKey) {
		fields = append(fields, usertask.FieldFormKey)
	}
	if m.FieldCleared(usertask.FieldActName) {
		fields = append(fields, usertask.FieldActName)
	}
	if m.FieldCleared(usertask.FieldOwner) {
		fields = append(fields, usertask.FieldOwner)
	}
	if m.FieldCleared(usertask.FieldAssignee) {
		fields = append(fields, usertask.FieldAssignee)
	}
	if m.FieldCleared(usertask.FieldCandidateUsers) {
		fields = append(fields, usertask.FieldCandidateUsers)
	}
	if m.FieldCleared(usertask.FieldCandidateGroups) {
		fields = append(fields, usertask.FieldCandidateGroups)
	}
	if m.FieldCleared(usertask.FieldOperator) {
		fields = append(fields, usertask.FieldOperator)
	}
	if m.FieldCleared(usertask.FieldResult) {
		fields = append(fields, usertask.FieldResult)
	}
	if m.FieldCleared(usertask.FieldEndTime) {
		fields = append(fields, usertask.FieldEndTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTaskMutation) ClearField(name string) error {
	switch name {
	case usertask.FieldExecID:
		m.ClearExecID()
		return nil
	case usertask.FieldFormKey:
		m.ClearFormKey()
		return nil
	case usertask.FieldActName:
		m.ClearActName()
		return nil
	case usertask.FieldOwner:
		m.ClearOwner()
		return nil
	case usertask.FieldAssignee:
		m.ClearAssignee()
		return nil
	case usertask.FieldCandidateUsers:
		m.ClearCandidateUsers()
		return nil
	case usertask.FieldCandidateGroups:
		m.ClearCandidateGroups()
		return nil
	case usertask.FieldOperator:
		m.ClearOperator()
		return nil
	case usertask.FieldResult:
		m.ClearResult()
		return nil
	case usertask.FieldEndTime:
		m.ClearEndTime()
		return nil
	}
	return fmt.Errorf("unknown UserTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTaskMutation) ResetField(name string) error {
	switch name {
	case usertask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case usertask.FieldInstID:
		m.ResetInstID()
		return nil
	case usertask.FieldExecID:
		m.ResetExecID()
		return nil
	case usertask.FieldBusiKey:
		m.ResetBusiKey()
		return nil
	case usertask.FieldBusiType:
		m.ResetBusiType()
		return nil
	case usertask.FieldFormKey:
		m.ResetFormKey()
		return nil
	case usertask.FieldActID:
		m.ResetActID()
		return nil
	case usertask.FieldActName:
		m.ResetActName()
		return nil
	case usertask.FieldOwner:
		m.ResetOwner()
		return nil
	case usertask.FieldAssignee:
		m.ResetAssignee()
		return nil
	case usertask.FieldCandidateUsers:
		m.ResetCandidateUsers()
		return nil
	case usertask.FieldCandidateGroups:
		m.ResetCandidateGroups()
		return nil
	case usertask.FieldOperator:
		m.ResetOperator()
		return nil
	case usertask.FieldInput:
		m.ResetInput()
		return nil
	case usertask.FieldBatchNo:
		m.ResetBatchNo()
		return nil
	case usertask.FieldResult:
		m.ResetResult()
		return nil
	case usertask.FieldStartTime:
		m.ResetStartTime()
		return nil
	case usertask.FieldEndTime:
		m.ResetEndTime()
		return nil
	case usertask.FieldStatus:
		m.ResetStatus()
		return nil
	case usertask.FieldVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown UserTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserTask edge %s", name)
}
